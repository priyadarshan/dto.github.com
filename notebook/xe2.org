#+OPTIONS: toc:2 *:nil 
#+TITLE: XE2: A 2D Common Lisp Game Engine
#+AUTHOR: David T. O'Toole <dto@gnu.org>

* What is XE2?

file:../images/xe2.png

XE2 is a [[http://en.wikipedia.org/wiki/Free_software][free-software]] Common Lisp 2D game engine. It is implemented
mostly in its own custom prototype-based object system, an extension
to Common Lisp called CLON.

CLON uses a message passing model, so instead of being limited to
straight function calls, you can optionally queue up, process,
redirect, and forward messages very freely. Because there are no
classes to restrict what methods may be invoked where, and because
most of the XE2 engine's functionality is implemented in the same
language as the gameworld and its behaviors, I've found that
programming games with CLON has a bit of the "plug anything into
anything" flavor that people attribute to "entity systems". However,
CLON is not an entity system, and is rather more Smalltalk-inspired.
Instead of class inheritance relationships determining control flow,
objects can discriminate amongst themselves by categorizing each other
with "tags" such as "actor" "opaque" "obstacle" "enemy" and so on.

CLON and XE2 are presently in beta, but [[http://dto.github.com/notebook/games.html][several working games]] have
been delivered for the PC platform (Win/Mac/Linux). I'm currently
making improvements in ease of use and adding developer documentation
to prepare for a 1.0 release of XE2. I am also working on an
interactive game creator/editor called [[file:xiomacs.org][XIOMACS]].

 - [[http://github.com/dto/xe2][XE2 Github repository]]
 - [[http://github.com/dto/clon][CLON Github repository]]
 - [[http://dto.github.com/notebook/games.html][Information about my games made with XE2]]
 - [[http://dto.github.com/notebook/xe2-reference.html][XE2 developer's reference]]. Needs updating.

* What is Common Lisp?

Common Lisp is the underlying programming language used to implement
CLON, XE2, and any game for it.

The [[http://en.wikipedia.org/wiki/Common_Lisp][wikipedia page on Common Lisp]] has an overview, code examples, and
links. Browsing through the examples there will familiarize you with
the syntax, which will help a lot in getting started with XE2. Here is
an [[http://abhishek.geek.nz/nanoc/docs/features-of-common-lisp/][interesting Common Lisp feature list]]. There are also many [[http://www.lispmachine.net/][free lisp
books]] and other educational resources. Another option is [[http://www.cliki.net/Education][this cliki
page]] about getting started with Common Lisp.

* What if I need help?

If the links above and the XE2 source comments are not enough, or if
you encounter errors, I will be happy to answer questions via [[mailto:dto1138@gmail.com][email]]
and interactively on IRC. Our community's IRC channel is at
irc.freenode.net, and the channel name is #lispgames. I go by the
hacker alias "DTO" there. (Actually it's just my initials.)

* Features

The XE2 game engine supports layered, tile-based 2D worlds with
interacting, independent agents called "cells". These cells' behaviors
are defined with CLON (Common Lisp Object Network) which adds
prototype-oriented objects to Common Lisp with a custom
syntax. Sprites are also supported, and these may collide with each
other and with grid cell objects. Sprites may be arbitrarily sized and
placed, whereas grid cells are uniform in size and are always
grid-aligned. Both turn-based and realtime play are supported. XE2
uses LISPBUILDER-SDL for cross-platform graphics and audio; games
built with XE2 can be distributed as binaries for GNU/Linux, Mac OSX,
and Microsoft Windows. (For an example, see [[http://dto.github.com/notebook/xong.html][XONG]].)  Other features
include:

 - Basic procedural content tools, including turtle graphics, generating sentences from context-free grammars, and plasma noise.
 - Map editor (working, but in progress: see [[http://www.youtube.com/watch?vE5KmZxQxiJ0][this video]] for a demo.)
 - GUI widgets: formatted text output, simple text editing, an extensible interactive command prompt, and more.
 - Ray-casting based lighting effects and line-of-sight.
 - A-star pathfinding.

* Preparing your XE2 development environment

First you need an operating system. Because XE2 runs on Linux, Mac,
and Windows, you can develop games on any of those platforms. (All the
development tools and libraries mentioned below are cross-platform and free).
 - GNU Emacs is strongly recommended for developing XE2 games, because
   of Emacs' excellent Lisp editing support, and also because SLIME
   allows you to develop and debug interactively from within the
   editor.
 - SLIME (Superior Lisp Interaction Mode for Emacs)
 - clon.el --- a short Emacs Lisp program that adds support for CLON
   syntax editing to Emacs. This is included with CLON.
 - SBCL (Steel Bank Common Lisp) is recommended.
 - LISPBUILDER-SDL and its prerequisites are required.
 - SDL, SDL-IMAGE, SDL-MIXER, SDL-GFX are required. You only need to
   worry about this if you use Linux.
 - GIMP, Audacity, Ardour, and so on can be used to edit audio and
   image files used as game resources.

Visit the repository to see the latest [[http://github.com/dto/xe2/tree/master/INSTALL][installation instructions]] for
getting started with LISPBUILDER-SDL, CLON, and XE2. Installing GNU
Emacs, SLIME, or the other programs mentioned above is beyond the
scope of this document, but most of them will have downloads available
on their websites.

In the future I would like to be able to deliver pre-made XE2
development kits, downloadable for each platform. 

* Introducing CLON

CLON stands for Common Lisp Object Network. CLON is a prototype-based
object system for Common Lisp. It is different from CLOS in several
important ways:
 - CLON is prototype-based, not class-based. A prototype is a template
   object from which other objects are "cloned".
 - Method invocation happens via message-passing, not generic
   functions; messages are conceptually different from synchronous
   function calls and may be freely queued, forwarded, and filtered.
 - Built-in support for serialization.
 - Simple and small: as of August 2010, clon.lisp contains just over 1,000 lines
   of code and commentary.
 - Special syntax support for message sending:

:   (/method-name object arg1 arg2 ...)

   and for accessing fields (i.e. "slots" in CLOS terminology):

:   (setf <field-name> value)

** What is an object in CLON?
A CLON object consists of a set of fields (keyword/value pairs),
and optionally: 
      - a name (usually a symbol naming a special variable)
      - a link to a parent object from which this object delegates slot lookups
[[file:../clon/clon.html#Object_data_structure][See also clon.lisp, "Object data structure"]]

** Defining objects

First we must define a prototype and name its fields:

: (define-prototype rectangle ()
:   x y width height)

[[file:../clon/clon.html#Defining_prototypes][See also clon.lisp, "Defining prototypes"]]

We could also have provided initialization forms and documentation strings:

: (define-prototype rectangle ()
:   (x :initform 0 
:      :documentation "The x-coordinate of the rectangle's top-left corner.")
:   (y :initform 0 
:      :documentation "The y-coordinate of the rectangle's top-left corner.")
:   (width :documentation "The width of the rectangle.")
:   (height :documentation "The height of the rectangle."))

** Defining objects that inherit behavior from a parent

And if there were a Shape prototype that we would like to use as a
template for Rectangle, we might have written:

: (define-prototype rectangle (:parent =shape=)
:   (x :initform 0 
:      :documentation "The x-coordinate of the rectangle's top-left corner.")
:   (y :initform 0 
:      :documentation "The y-coordinate of the rectangle's top-left corner.")
:   (width :documentation "The width of the rectangle.")
:   (height :documentation "The height of the rectangle."))

Notice the equals signs surrounding the parent object's name; all
objects made with define-prototype are accessible via special
variables with such names.

** Accessing fields

Field accesses can be written with the angle brackets; this
works both for reading and for writing, so long as you use =setf= for
the latter. 

You can also bind fields to variables, using the macro WITH-FIELDS. In
this way you can refer to fields like ordinary variables, and these
work with SETF as place-forms:

: (define-method close browser ()
:   (with-fields (address tabs recently-closed) self
:     (let ((tab (pop tabs)))
:       (setf address nil)
:       (push (tab-address tab) recently-closed))))

** Cloning and initialization

The function CLONE is used to create new objects from these
prototypes. Now we write an initializer, which is passed any creation
arguments at the time of cloning:

: (define-method initialize rectangle (&key width height)
:   (setf <width> width)
:   (setf <height> height))

(This may seem like overkill in the small example, but is very useful
when you refer to a field many times in a method.)

(All these ways of accessing fields are frontends for the functions
FIELD-VALUE and SET-FIELD-VALUE, but using these is not normally
necessary. )

: (define-method initialize rectangle (&key width0 height0)
:   (with-fields (width height) self
:     (setf width width0)
:     (setf height height0)))

Now when you say:

: (clone =rectangle= :width 5 :height 12)

The rectangle's initializer method is invoked with those arguments,
and a rectangle of the correct height and width is created.

** Defining methods

Now we define a few methods:

: (define-method area rectangle ()
:   (* <width> <height>))
:
: (define-method print rectangle (&optional (stream t))
:   (format stream "height: ~A width: ~A area: ~A"
: 	  <height> <width> 
: 	  (/area self)))

And invoke them with the aforementioned special notation:

: (defvar rect (clone =rectangle= :width 10 :height 8))
: (/print rect)

The result: 

: "height: 8 width: 10 area: 80"

** Serializing objects

** clon.el: Emacs editing support for CLON
CLON includes a small Emacs Lisp program that adds optional support
for CLON syntax, complete with fontification. 
To set up clon.el, add the following to your Emacs initialization file:
: (add-to-list 'load-path "~/clon") ;; Change this to where you installed CLON
: (require 'clon)
: (add-hook 'lisp-mode-hook #'clon-do-font-lock)

** Message queueing
CLON also supports a concept called message queueing. When there is an
active message queue, messages may be entered into the queue instead
of directly invoking a method:
: [queue>>render widget]
: [queue>>attack self :north]
The sender, receiver, method name, and arguments are all recorded in
the queue. The developer can then filter or process them before
sending.
[[file:../clon/clon.html#Message_queueing][See also clon.lisp, "Message queueing"]]
** Message forwarding
And finally, I will mention message forwarding, which handles the case
that an object has no handler for a particular method. This is akin to
[[http://en.wikipedia.org/wiki/Smalltalk][Smalltalk's]] "doesNotUnderstand" concept.
[[file:../clon/clon.html#Message_forwarding][See also clon.lisp, "Message forwarding"]]

: (define-method forward browser (method &rest args)
:   (let ((tab (first <tabs>)))
:     (apply #'send self method tab args)))

* Design overview

In this section we take a brief tour of the main areas of
functionality from a design perspective. After that, we will delve
into API details from a programmer's point of view. 
** CLON 
CLON is an object system designed especially for games. It uses
prototypes instead of classes, and has built-in support for
serialization. Messages (i.e. method invocations) can be queued and
pre-processed before sending to their recipients. Message forwarding
(i.e. doesNotUnderstand) is also supported.
See also [[http://github.com/dto/clon/blob/master/clon.lisp][clon.lisp]].
** The console
The "console" is an imaginary video game machine whose native language
is Common Lisp. XE2 games are implemented as "modules" that plug in to
the system, akin to old cartridges or tapes. All services of the
engine (opening the screen, drawing text and images, playing sounds,
joystick input) are provided here with a platform-neutral Common Lisp
interface. Currently the console uses LISPBUILDER-SDL as a
backend, but other backends are possible.
See also [[http://github.com/dto/xe2/blob/master/console.lisp][console.lisp]].
** Interactive graphical widgets
Widgets are CLON graphical user interface objects. The console is
designed to draw a set of "active widgets" to the screen for each
video frame. The console also delivers event data to these
widgets. Events are things like keystrokes, joystick buttons, timers,
or mouse clicks. The keybinding system (where events are mapped to
responses) draws inspiration from Emacs.
Also included in [[http://github.com/dto/xe2/blob/master/widgets.lisp][widgets.lisp]]:
  - basic layout widgets 
  - an interactive command prompt 
  - an Emacs-like formatter with fontification and inline images
  - scrolling text box widget
  - a "pager" to switch between different active widget layouts using hotkeys.
** Cells
"Cells" are interacting CLON objects. Each cell represents some
in-game entity; player characters, enemies, weapons, items, walls and
floors are all different types of cells. Game play occurs in a
three-dimensional grid of cells called a World (see below).
Cells may be stacked along the z-axis, and may also contain other
cells. Cells interact by sending messages to one another and to other
objects in the environment; these messages are queued and processed by
the world for delivery to their recipients.
In [[http://github.com/dto/xe2/blob/master/cells.lisp][cells.lisp]]
you will find some basic roguelike logic built into cells.
  - Basic features like name, description, and discovery.
  - Unified container, inventory, and equipment system.
  - Cells have an optional weight in kilograms, and the calculation
    recursively includes containers and equipment.
  - The "action points" system allocates game turns to different
    cells. 
  - Basic melee and ranged combat support.
  - Equipment slot system (i.e. "paper doll") not restricted to humanoid actors.
  - "Proxying", a feature used to implement drivable vehicles and/or demonic possession.
  - "Stats", for numeric-valued attributes susceptible to temporary
    and permanent effects (i.e. stat increases and drains, or
    encumbrance). Also supports setting minimum and maximum values,
    and keeping track of units (meters, kilograms.)
  - "Categories" allow arbitrary tagging of objects, with some
    categories having special interpretation by the engine.
These are in effect a basic set of roleplaying rules or "physics". By
defining new prototypes based on cells, you can change the rules and
run the game the way you want.

 - /NOTE: Some of the game logic described above is being factored out into an optional module./

** Worlds composed of cells
A World object ties together all the elements of XE2 into a playable
situation. A World is a 2.5D grid of interacting cells. This object
performs the following tasks:
 - Keeps track of a single player and delivers command messages to the player cell
 - Time and turns for player and CPU (the "Action Points system")
 - Lighting and sound propagation
 - Generating the map and placing cells on maps.
 - Queueing and processing messages 
There are also Universe objects composed of interlinked worlds.
See also [[http://github.com/dto/xe2/blob/master/worlds.lisp][worlds.lisp]].
** Math routines
 - Basic dice rolls
 - Distance, compass directions
 - Drawing shapes made of cells
 - Bresenham's line algorithm
 - Random midpoint displacement "plasma"
 See also [[http://github.com/dto/xe2/blob/master/math.lisp][math.lisp.]]
** Pathfinding
Not yet fully ported. See [[http://github.com/dto/xe2/blob/master/path.lisp][path.lisp.]]

* A tiny example breakout game
